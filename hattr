#!/usr/bin/env perl

################################################################################
# Mode options
# -l    Default: Print some status line
# -n    Write new metadata where it doesn't exist
# -v    Verify metadata where it exists
# -a    Combination -n & -v
# -x    Delete all metadata.
# -i    (import)
# -e    (export)

################################################################################
# Output: status column
#  		[space] no metadata
# ?		initial-hashed but unverified
# V		last verification passed
# X		last verification failed

use strict;
use warnings;

use DateTime qw(now);

my $mode = shift;

if (not defined $mode && $mode =~ m/^-[lnvaxe]$/) {
    print "Incorrect usage!\n";
    exit 1;
}

foreach my $item (@ARGV) {
	die "Path '$item' not found" if (not -e $item);
	die "Path '$item' is not a file" if (not (-f $item or -d $item));
}

foreach my $item (@ARGV) {
	&item_process($item, $mode);
}

exit(0);

################################################################################
# Initial-hash the file if it hasn't already been done
sub item_process {
    my ($item,$mode) = @_;

	if (-d $item) {
		opendir(my $handle, $item) or die "Cannot open directory '$!'";
		my @list = readdir($handle);

		foreach my $nested (@list) {
			next if $nested eq "." or $nested eq "..";
			&item_process("$item/$nested", $mode);
		}

		closedir($handle);
		
		return;
	}

	#&file_list  ($item) if ($mode =~ m/-l/);
	&file_new   ($item)     if ($mode =~ m/-n/);
	&file_verify($item)     if ($mode =~ m/-v/);
	&file_all   ($item)     if ($mode =~ m/-a/);
	&file_remove($item)     if ($mode =~ m/-x/);
	&file_export($item)     if ($mode =~ m/-e/);
}

################################################################################
# Initial-hash the file if it hasn't already been done
sub file_new {
    my ($file) = @_;

    my $stored = &get_stored_hash($file);

	if (not defined $stored) {
		&hash_and_store($file);
		print "? $file\n";
		return;
	}

	my %meta = &meta_get($file);

	printf "%s $file\n", $meta{state} // '?';
	return;
}

################################################################################
# Verify the file if it's been initial-hashed
sub file_verify {
	my ($file) = @_;

	my $stored = &get_stored_hash($file);

	unless (defined $stored) {
		# No existing hash - skip file
		print "  $file\n";
		return;
	}

	if (&verify_hash($file,$stored)) {
		my $time = DateTime->now;
		system("setfattr --restore=- <<EOF
# file: $file
user.hattr.state=\"V\"
user.hattr.vtime=\"$time\"
EOF
");
		print "V $file\n";
	}
	else {
		system("setfattr --restore=- <<EOF
# file: $file
user.hattr.state=\"X\"
EOF
");
		print "X $file\n";
	}
}

################################################################################
# Verify the file if it's been initial-hashed; otherwise initial-hash it
sub file_all {
	my ($file) = @_;

	my $stored = &get_stored_hash($file);

	return &file_verify($file) if (defined $stored);
	return &file_new($file);
}

################################################################################
# Remove all metadata from the file
sub file_remove {
    my ($file) = @_;

    system("setfattr --remove=user.hattr.md5   '$file' >/dev/null 2>&1");
    system("setfattr --remove=user.hattr.htime '$file' >/dev/null 2>&1");
    system("setfattr --remove=user.hattr.state '$file' >/dev/null 2>&1");
    system("setfattr --remove=user.hattr.vtime '$file' >/dev/null 2>&1");

	print "  $file\n";
}

################################################################################
# Print a status line for the file in `md5deep -zl` formst
sub file_export {
    my ($file) = @_;
	my $size = -s $file;
	my $stored  =  &get_stored_hash($file) // '????????????????????????????????';
	printf("%10u  $stored  $file\n", $size);
}

################################################################################
# HELPERS

################################################################################
# Store the supplied hash into a file's metadata
sub store_hash {
    my ($file, $hash) = @_;
    my $time = DateTime->now; # This is UTC
    system("setfattr --restore=- <<EOF
# file: $file
user.hattr.md5=\"$hash\"
user.hattr.htime=\"$time\"
EOF
");
}

################################################################################
# Hash the file and write metadata
sub hash_and_store {
    my ($file) = @_;
    my $hash = &hash_content($file);
	return &store_hash($file, $hash);
}

################################################################################
# Read back a hash from a file and compare
sub verify_hash {
    my ($file,$stored) = @_;
    return &hash_content($file) eq $stored;
}

################################################################################
# Hash the file and return the resulting hash
sub hash_content {
    my ($file) = @_;
    my $hash = `md5sum '$file' | cut -d ' ' -f 1`;
    chomp $hash;
    return $hash;
}

################################################################################
# Read back a hash from a file.
sub get_stored_hash {
    my ($file) = @_;
    my $hash = `getfattr -d '$file' | grep user.hattr.md5 | sed 's/user.hattr.md5="//' | sed 's/"\$//'`;
    chomp $hash;
    return 32==length($hash) ? $hash : undef;
}

################################################################################
# Retrieve metadata from a file's extended attributes
# TODO deduplicate with the version in the tests file
sub meta_get() {
    my ($file) = @_;

    my $dump=`getfattr -d '$file'`;

    open my $fh, '<', \$dump;

    my %fields;
    while (<$fh>) {
        next unless m/^[\s]*user.hattr.(md5|htime|state|vtime)="(.*)"[\s]*$/;
        $fields{$1} = $2;
    }

    return %fields;
}