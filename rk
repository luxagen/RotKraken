#!/usr/bin/env perl

################################################################################
# Mode options
# -l    Default: Print some status line
# -n    Write new metadata where it doesn't exist
# -f    Write metadata regardless
# -v    Verify metadata where it exists
# -a    Combination -n & -v
# -x    Delete all metadata.
# -i    (import)
# -e    (export)

use strict;
use warnings;

use DateTime qw(now);

my $mode = shift;
my $file = shift;

if (not defined $mode && $mode =~ m/^-[lnfvaxie]$/) {
    print "Incorrect usage!\n";
    exit 1;
}

#&mode_list  ($file) if ($mode =~ m/-l/);
&mode_new   ($file) if ($mode =~ m/-n/);
&mode_force ($file) if ($mode =~ m/-f/);
&mode_verify($file) if ($mode =~ m/-v/);
#&mode_all   ($file) if ($mode =~ m/-a/);
&mode_remove($file) if ($mode =~ m/-x/);
#&mode_import($file) if ($mode =~ m/-i/);
#&mode_export($file) if ($mode =~ m/-e/);

################################################################################
# Main program loop.
#foreach my $file (@ARGV) {
#}

################################################################################
# Initial-hash the file if it hasn't already been done
sub mode_new {
    my ($file) = @_;
    my $existing_hash = &read_existing_hash($file);
    if (defined $existing_hash && $existing_hash ne ''){
        print "$file already has a hash: $existing_hash -- Skipping\n";
    } else {
        print "Creating a new hash for $file\n";
        &create_new_hash($file);
    }
}

################################################################################
# Initial-hash the file indiscriminately
sub mode_force {
	return &create_new_hash($file);
}

################################################################################
# Verify the file if it's been initial-hashed
sub mode_verify {
	my ($file) = @_;

	my $stored = &read_existing_hash($file);

	return if ($stored eq ''); # No existing hash - skip file

	if (&verify_hash($file, $stored)) {
		my $time = DateTime->now;
		system("setfattr --restore=- <<EOF
# file: $file
user.rk.state=\"V\"
user.rk.vtime=\"$time\"
EOF
			");
	}
	else {
		system("setfattr --restore=- <<EOF
# file: $file
user.rk.state=\"X\"
EOF
");
	}
}

################################################################################
# Remove all metadata from the file
sub mode_remove {
    my ($file) = @_;
    system("setfattr --remove=user.rk.md5   '$file' >/dev/null 2>&1");
    system("setfattr --remove=user.rk.htime '$file' >/dev/null 2>&1");
    system("setfattr --remove=user.rk.state '$file' >/dev/null 2>&1");
    system("setfattr --remove=user.rk.vtime '$file' >/dev/null 2>&1");
}

################################################################################
# HELPERS

################################################################################
# Hash the file and write the hash+htime to the file metadata.
sub create_new_hash {
    my ($file) = @_;
    my $hash = &hash_file($file);
    my $time = DateTime->now;
    system("setfattr --restore=- <<EOF
# file: $file
user.rk.md5=\"$hash\"
user.rk.htime=\"$time\"
EOF
");
}

################################################################################
# Read back a hash from a file and compare
sub verify_hash {
    my ($file, $stored) = @_;
    return &hash_file($file) eq $stored;
}

################################################################################
# Hash the file and return the resulting hash
sub hash_file {
    my ($file) = @_;
    my $hash = `md5sum '$file' | cut -d ' ' -f 1`;
    chomp $hash;
    return $hash;
}

################################################################################
# Read back a hash from a file.
sub read_existing_hash {
    my ($file) = @_;
    my $hash = `getfattr -d '$file' | grep user.rk.md5 | sed 's/user.rk.md5="//' | sed 's/"\$//'`;
    chomp $hash;
    return $hash;
}

################################################################################
