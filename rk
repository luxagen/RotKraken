#!/usr/bin/env perl
use strict;
use warnings;

use DateTime qw(now);
use File::ExtAttr ':all';
use Digest::MD5::File qw(file_md5_hex);
use Getopt::Lucid qw( :all );

my @options_spec = (
	Switch("delete|d")->doc("Delete RotKraken metadata from extended attributes"),
	Switch("export|e")->doc("Export hash log to stdout in the same format as `md5deep -zl`"),
	Switch("init|i")->doc("Initialise files that are missing metadata"),
	Switch("verify|v")->doc("Verify files against metadata"),
	Switch("init_verify|a")->doc("Combination of -i & -v"),
	Switch("status|s")->doc("Show status but do nothing"),
	Switch("help|h"),
);

# read config in a way that means we can output usage info
# https://github.com/dagolden/Getopt-Lucid/blob/e39a85a03d838020d53eb0490b4a567b550d398b/lib/Getopt/Lucid.pm#L1480-L1492
my $options = Getopt::Lucid->getopt( \@options_spec )->validate();

usage() and exit(0) if $options->get_help;

my $mode_delete = $options->get_delete;
my $mode_export = $options->get_export;
my $mode_init = $options->get_init;
my $mode_verify = $options->get_verify;
my $mode_init_verify = $options->get_init_verify;
my $mode_status = $options->get_status;
print("Error: No options specified.\n\n") and usage() and exit(1) unless $mode_delete or $mode_export or $mode_init or $mode_verify or $mode_init_verify or $mode_status;

my $no_recurse = 0;
my $no_follow_file_symlinks = 1;
my $no_follow_dir_symlinks = 1;

# remaining non-option arguments should be the file/folder list to process
print("Error: No paths specified.\n\n") and usage() and exit(1) unless @ARGV;
foreach my $item (@ARGV) {
	print "Path '$item' not found\n" and exit(2) if (not -e $item);
	print "Path '$item' is not a file\n" and exit(3) if (not (-f $item or -d $item));
}

foreach my $item (@ARGV) {
	&item_process($item);
}

exit(0);

sub usage {
	print $options->usage();

	print <<EOF
        arguments: the list of paths to process

Status characters:

        |   char  | meaning                               |
        | ------: | :------                               |
        | <space> | No metadata (or just removed)         |
        |       N | Just hashed, metadata added           |
        |       ? | Previously hashed but never verified  |
        |       V | Last verify passed, vtime updated     |
        |       X | Last verify failed, vtime not updated |

https://github.com/luxagen/RotKraken

EOF
}

################################################################################
# Initial-hash the file if it hasn't already been done
sub item_process {
    my ($item) = @_;

	if (-d $item) {
		return if ($no_recurse);
		return if (-l $item  and  $no_follow_dir_symlinks);

		opendir(my $handle, $item) or die "Cannot open directory '$!'";
		my @list = readdir($handle);

		foreach my $nested (@list) {
			next if $nested eq "." or $nested eq "..";
			&item_process("$item/$nested");
		}

		closedir($handle);

		return;
	}

	return if (-l $item  and  $no_follow_file_symlinks);
	return &file_remove($item) if ($mode_delete);
	return &file_export($item) if ($mode_export);
	return &file_init  ($item) if ($mode_init);
	return &file_verify($item) if ($mode_verify);
	return &file_all   ($item) if ($mode_init_verify);
	return &file_status($item) if ($mode_status);
}

################################################################################
# Initial-hash the file if it hasn't already been done
sub file_init {
    my ($file) = @_;

	my $m = &meta_get($file);
	return if not defined $m;
	my %meta = %{$m};

	if (not defined $meta{md5}) {
		&hash_and_store($file);
		return print_status($file, 'N');
	}

	return print_status($file, $meta{state} // '?');
}

################################################################################
# Verify the file if it's been initial-hashed
sub file_verify {
	my ($file) = @_;

	my $m = &meta_get($file);
	return if not defined $m;
	my %meta = %{$m};

	return print_status($file, ' ') unless (defined $meta{md5}); # No existing hash? Skip file

	if (&verify_hash($file, $meta{md5})) {
		&setfattr($file, 'rk.state', 'V');
		&setfattr($file, 'rk.vtime', DateTime->now);
		print_status($file, 'V');
	}
	else {
		&setfattr($file, 'rk.state', 'X');
		print_status($file, 'X');
	}
}

################################################################################
# Verify the file if it's been initial-hashed; otherwise initial-hash it
sub file_all {
	my ($file) = @_;

	my $m = &meta_get($file);
	return if not defined $m;
	my %meta = %{$m};

	return &file_verify($file) if (defined $meta{md5});
	return &file_init($file);
}

################################################################################
# Remove all metadata from the file
sub file_remove {
    my ($file) = @_;

	my $out;
	my $err;

	# Discard stderr and ignore return codes to make a best effort at xattr deletion

	foreach ('md5', 'htime', 'state', 'vtime') {
		&delfattr($file, "rk.$_");
	}

	print_status($file, ' ');
}

################################################################################
# Print a status line for the file in `md5deep -zl` formst
sub file_export {
    my ($file) = @_;
	my $size = -s $file;

	my $m = &meta_get($file);
	return if not defined $m;
	my %meta = %{$m};

	printf(
		"%10u  %s  %s\n",
		$size,
		$meta{md5} // '????????????????????????????????',
		&filename_for_output($file));
}

################################################################################
# Print a status line for the file without doing anything
sub file_status {
    my ($file) = @_;
	my $m = &meta_get($file);
	return if not defined $m;
	my %meta = %{$m};

	&print_status($file, $meta{state} // '?');
}


################################################################################
# HELPERS

sub filename_for_output {
	return $_[0] =~ s/\n/\\n/gr;
}

sub print_status {
    my ($file, $status) = @_;

	printf(
		"%s %s\n",
		$status,
		&filename_for_output($file));
}

################################################################################
# Store the supplied hash into a file's metadata
sub store_hash {
    my ($file, $hash) = @_;

	&setfattr($file, 'rk.md5', $hash);
	&setfattr($file, 'rk.htime', DateTime->now);
}

################################################################################
# Hash the file and write metadata
sub hash_and_store {
    my ($file) = @_;
    my $hash = &hash_content($file);
	&store_hash($file, $hash) if (defined $hash);
}

################################################################################
# Read back a hash from a file and compare
sub verify_hash {
    my ($file,$stored) = @_;
    return &hash_content($file) eq $stored;
}

################################################################################
# Hash the file and return the resulting hash
sub hash_content {
    my ($file) = @_;
	return &file_md5_hex($file);
}

################################################################################
# Retrieve metadata from a file's extended attributes
# TODO deduplicate with the version in the tests file
sub meta_get() {
    my ($file) = @_;

	my $out;

	my %fields;

	foreach ('md5', 'htime', 'state', 'vtime') {
		my $value = &getfattr($file, "rk.$_");
		$fields{$_} = $value if (defined $value);
	}

	# Individual validation
	not defined $fields{md5}  or  $fields{md5} =~ /^[\da-f]{32}$/  or  die 'Bad hash!';
	not defined $fields{htime}  or  $fields{htime} =~ /\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}/  or  die 'Bad htime!';
	not defined $fields{state}  or  $fields{state} =~ /[VX]/  or  die 'Bad state!';
	not defined $fields{vtime}  or  $fields{vtime} =~ /\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}/  or  die 'Bad htime!';

	# Collective validation: md5 and htime must appear together, and neither state nor vtime must appear without them
	delete @fields{'md5', 'htime', 'state', 'vtime'} if (not (defined $fields{md5} and defined $fields{htime}));
	delete @fields{'state', 'vtime'} if (not defined $fields{state});

    return \%fields;
}
