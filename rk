#!/usr/bin/env perl

################################################################################
# Mode options
# -l    Default: Print some status line
# -n    Write new metadata where it doesn't exist
# -v    Verify metadata where it exists
# -a    Combination -n & -v
# -x    Delete all metadata.
# -i    (import)
# -e    (export)
# TODO  option to disable symlink following

################################################################################
# Output: status column
#  		[space] no metadata
# ?		initial-hashed but unverified
# V		last verification passed
# X		last verification failed

use strict;
use warnings;

use DateTime qw(now);
use String::ShellQuote qw(shell_quote);

my $mode = shift;

die "Incorrect usage!\n" if (not defined $mode && $mode =~ m/^-[lnvaxe]$/);

my $no_follow_symlinks = 0;

foreach my $item (@ARGV) {
	die "Path '$item' not found" unless -e $item;
	die "Path '$item' is not a file" unless -f $item  or  -d $item;
}

foreach my $item (@ARGV) {
	&item_process($item, $mode);
}

exit(0);

################################################################################
# Process a filesystem item
sub item_process {
    my ($item,$mode) = @_;

	if (-d $item) {
		opendir(my $handle, $item) or die "Cannot open directory '$!'";
		my @list = readdir($handle);

		foreach my $nested (@list) {
			next if $nested eq "."  or  $nested eq "..";
			&item_process("$item/$nested", $mode);
		}

		closedir($handle);
		
		return;
	}

	if ($mode =~ m/-x/) {
		&file_remove($item);
		return;
	}

	if ($mode =~ m/-e/) {
		&file_export($item);
		return;
	}

	if ($no_follow_symlinks) {
		print "L $item\n";
		return;
	}

	#&file_list  ($item) if ($mode =~ m/-l/);
	&file_new   ($item) if ($mode =~ m/-n/);
	&file_verify($item) if ($mode =~ m/-v/);
	&file_all   ($item) if ($mode =~ m/-a/);
}

################################################################################
# Initial-hash the file if it hasn't already been done
sub file_new {
    my ($file) = @_;

	my %meta = &meta_get($file);

	if (not defined $meta{md5}) {
		&hash_and_store($file);
		print "? $file\n";
		return;
	}

	printf "%s $file\n", $meta{state} // '?';
	return;
}

################################################################################
# Verify the file if it's been initial-hashed
sub file_verify {
	my ($file) = @_;

	my %meta = &meta_get($file);

	unless (defined $meta{md5}) {
		# No existing hash - skip file
		print "  $file\n";
		return;
	}

	if (&verify_hash($file, $meta{md5})) {
		my $time = DateTime->now;
		system("setfattr --restore=- <<EOF
# file: $file
user.rk.state=\"V\"
user.rk.vtime=\"$time\"
EOF
");
		print "V $file\n";
	}
	else {
		system("setfattr --restore=- <<EOF
# file: $file
user.rk.state=\"X\"
EOF
");
		print "X $file\n";
	}
}

################################################################################
# Verify the file if it's been initial-hashed; otherwise initial-hash it
sub file_all {
	my ($file) = @_;

	my %meta = &meta_get($file);

	return &file_verify($file) if (defined $meta{md5});
	return &file_new($file);
}

################################################################################
# Remove all metadata from the file
sub file_remove {
    my ($file) = @_;

	my $sq = shell_quote($file);

    system("setfattr --remove=user.rk.md5   $sq >/dev/null 2>&1");
    system("setfattr --remove=user.rk.htime $sq >/dev/null 2>&1");
    system("setfattr --remove=user.rk.state $sq >/dev/null 2>&1");
    system("setfattr --remove=user.rk.vtime $sq >/dev/null 2>&1");

	print "  $file\n";
}

################################################################################
# Print a status line for the file in `md5deep -zl` formst
sub file_export {
    my ($file) = @_;
	my $size = -s $file;

	if ($no_follow_symlinks) {
		printf("%10u  llllllllllllllllllllllllllllllll  $file\n", $size);
		return;
	}

	my %meta = &meta_get($file);

	my $stored  =  $meta{md5} // '????????????????????????????????';
	printf("%10u  $stored  $file\n", $size);
}

################################################################################
# HELPERS

################################################################################
# Store the supplied hash into a file's metadata
sub store_hash {
    my ($file, $hash) = @_;
    my $time = DateTime->now; # This is UTC
    system("setfattr --restore=- <<EOF
# file: $file
user.rk.md5=\"$hash\"
user.rk.htime=\"$time\"
EOF
");
}

################################################################################
# Hash the file and write metadata
sub hash_and_store {
    my ($file) = @_;
    my $hash = &hash_content($file);
	return &store_hash($file, $hash);
}

################################################################################
# Read back a hash from a file and compare
sub verify_hash {
    my ($file, $stored) = @_;
    return &hash_content($file) eq $stored;
}

################################################################################
# Hash the file and return the resulting hash
sub hash_content {
    my ($file) = @_;

	$file = shell_quote($file);

    my $hash = `md5sum $file | cut -d ' ' -f 1`;
    chomp $hash;
    return $hash;
}

################################################################################
# Retrieve metadata from a file's extended attributes
# TODO deduplicate with the version in the tests file
sub meta_get() {
    my ($file) = @_;

	$file = shell_quote($file);

    my $dump=`getfattr -d $file`;

    open my $fh, '<', \$dump;

    my %fields;
    while (<$fh>) {
        next unless m/^[\s]*user.rk.(md5|htime|state|vtime)="(.*)"[\s]*$/;
        $fields{$1} = $2;
    }

	# Individual validation
	die 'Bad hash!'  if defined   $fields{md5}    and  $fields{md5}   !~ /^[\da-f]{32}$/;
	die 'Bad htime!' if defined   $fields{htime}  and  $fields{htime} !~ /\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}/;
	die 'Bad state!' if defined   $fields{state}  and  $fields{state} !~ /[VX]/;
	die 'Bad htime!' if defined   $fields{vtime}  and  $fields{vtime} !~ /\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}/;

	# Collective validation: md5 and htime must appear together, and neither state nor vtime must appear without them
	delete @fields{'md5', 'htime', 'state', 'vtime'} unless  defined $fields{md5} and defined $fields{htime};
	delete @fields{'state', 'vtime'} unless defined $fields{state};

    return %fields;
}