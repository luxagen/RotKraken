#!/usr/bin/env perl

use strict;
use warnings;

use Test::More qw(no_plan); # for the is() and isnt() functions
use IPC::Run qw(run);
use File::Path qw(make_path rmtree);
use FindBin;
my $testee = "$FindBin::Bin/rk";

################################################################################
# Test constants

my $v1 = 'abcdefghijklmnopqrstuvwxyz';
my $v2 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
my $v3 = '0123456789';

my $h1 = 'c3fcd3d76192e4007dfb496cca67e13b';
my $h2 = '437bba8e0bf58337674f4539e75186ac';
my $h3 = '781e5e245d69b566979b86e28d23f2c7';

my $f1 = "1 with space.testfile";
my $f2 = "2 with space.testfile";
my $f3 = "3 with space.testfile";

################################################################################
# Testing program

foreach my $fs (@ARGV) {
	&test_nx($fs);
	&test_nv($fs);
	&test_a ($fs);
	&test_e ($fs);
	&test_l ($fs);
	&test_r ($fs);
}

exit 0;

################################################################################

sub test_nx() {
	my ($fs) = @_;
	my %meta;

	&clobber_file("$fs/$f1", $v1);

	%meta = &meta_get("$fs/$f1");
	&is(scalar keys %meta,0);

	&is(&invoke('n', ("$fs/$f1")), "? $fs/$f1\n");
	%meta = &meta_get("$fs/$f1");
	&is(scalar keys %meta,2);
	&is($meta{md5},$h1);
	&is(length($meta{htime}),19);

	my $htime = $meta{htime};

	&is(&invoke('n', ("$fs/$f1")), "? $fs/$f1\n");
	%meta = &meta_get("$fs/$f1");
	&is(scalar keys %meta,2);
	&is($meta{md5},$h1);
	&ok($meta{htime} eq $htime);

	&clobber_file("$fs/$f1", $v2);

	sleep(1); # Make sure timestamp changes
	&is(&invoke('x', ("$fs/$f1")), "  $fs/$f1\n");
	%meta = &meta_get("$fs/$f1");
	&is(scalar keys %meta,0);

    unlink "$fs/$f1";
}

sub test_nv() {
	my ($fs) = @_;
	my %meta;

	&clobber_file("$fs/$f1", $v1);

	%meta = &meta_get("$fs/$f1");
	&is(scalar keys %meta,0);

	&is(&invoke('v', ("$fs/$f1")), "  $fs/$f1\n");
	%meta = &meta_get("$fs/$f1");
	&is(scalar keys %meta,0);

	&is(&invoke('n', ("$fs/$f1")), "? $fs/$f1\n");
	%meta = &meta_get("$fs/$f1");
	&is(scalar keys %meta,2);
	&is($meta{md5},$h1);
	&is(length($meta{htime}),19);

	my $htime = $meta{htime};

	sleep(1); # Make sure timestamp changes
	&is(&invoke('v', ("$fs/$f1")), "V $fs/$f1\n");
	%meta = &meta_get("$fs/$f1");
	&is(scalar keys %meta,4);
	&is($meta{md5},$h1);
	&is($meta{htime},$htime);
	&is($meta{state},'V');
	&ok($meta{vtime} gt $meta{htime});

	my $last_vtime = $meta{vtime};

	&clobber_file("$fs/$f1", $v2);

	sleep(1); # Make sure timestamp changes
	&is(&invoke('v', ("$fs/$f1")), "X $fs/$f1\n");
	%meta = &meta_get("$fs/$f1");
	&is(scalar keys %meta,4);
	&is($meta{md5},$h1);
	&is($meta{htime},$htime);
	&is($meta{state},'X');
	&ok($meta{vtime} eq $last_vtime);

    unlink "$fs/$f1";
}

sub test_a() {
	my ($fs) = @_;
	my %meta;

	&clobber_file("$fs/$f1", $v1);

	%meta = &meta_get("$fs/$f1");
	&is(scalar keys %meta,0);

	&is(&invoke('a', ("$fs/$f1")), "? $fs/$f1\n");
	%meta = &meta_get("$fs/$f1");
	&is(scalar keys %meta,2);
	&is($meta{md5},$h1);
	&is(length($meta{htime}),19);

	my $htime = $meta{htime};

	&clobber_file("$fs/$f1", $v3);
	&clobber_file("$fs/$f2", $v2);

	%meta = &meta_get("$fs/$f2");
	&is(scalar keys %meta,0);

	sleep(1); # Make sure timestamp changes
	&is(
		&invoke('a', ("$fs/$f1", "$fs/$f2")),
		"X $fs/$f1\n? $fs/$f2\n");
	%meta = &meta_get("$fs/$f1");
	&is(scalar keys %meta,3);
	&is($meta{md5},$h1);
	&is($meta{htime},$htime);
	&is($meta{state},'X');
	%meta = &meta_get("$fs/$f2");
	&is(scalar keys %meta,2);
	&is($meta{md5},$h2);
	&ok($meta{htime} gt $htime);

    unlink "$fs/$f1", "$fs/$f2";
}

sub test_e {
	my ($fs) = @_;
	my %meta;

	&clobber_file("$fs/$f1", $v1);

	%meta = &meta_get("$fs/$f1");
	&is(scalar keys %meta,0);

	&is(&invoke('e', ("$fs/$f1")), "        26  ????????????????????????????????  $fs/$f1\n");
	%meta = &meta_get("$fs/$f1");
	&is(scalar keys %meta,0);

	&is(&invoke('a', ("$fs/$f1")), "? $fs/$f1\n");
	%meta = &meta_get("$fs/$f1");
	&is(scalar keys %meta,2);
	&is($meta{md5},$h1);
	&is(length($meta{htime}),19);

	&is(&invoke('e', ("$fs/$f1")), "        26  $h1  $fs/$f1\n");
	%meta = &meta_get("$fs/$f1");
	&is(scalar keys %meta,2);
	&is($meta{md5},$h1);
	&is(length($meta{htime}),19);

    unlink "$fs/$f1";
}

sub test_l {
	my ($fs) = @_;
	my %meta;

	&clobber_file("$fs/$f1", $v1);

	%meta = &meta_get("$fs/$f1");
	&is(scalar keys %meta,0);

	symlink($f1, "$fs/$f2") or die "Couldn't create symlink!";

	%meta = &meta_get("$fs/$f2");
	&is(scalar keys %meta,0);

	&is(&invoke('n', ("$fs/$f2")), "? $fs/$f2\n");
	%meta = &meta_get("$fs/$f2");
	&is(scalar keys %meta,2);
	&is($meta{md5},$h1);
	&is(length($meta{htime}),19);

	my $htime = $meta{htime};

	%meta = &meta_get("$fs/$f1");
	&is(scalar keys %meta,2);
	&is($meta{md5},$h1);
	&ok($meta{htime} eq $htime);

	unlink "$fs/$f1","$fs/$f2";
}

sub test_r() {
	my ($fs) = @_;
	my %meta;

	make_path("$fs/dir1/dir2","$fs/dir1/dir3");

	&clobber_file("$fs/dir1/$f1", $v1);
	&clobber_file("$fs/dir1/dir2/$f1", $v1);
	&clobber_file("$fs/dir1/dir2/$f2", $v2);
	&clobber_file("$fs/dir1/dir3/$f1", $v1);
	&clobber_file("$fs/dir1/dir3/$f3", $v3);

	my @expected = sort(
		"? $fs/dir1/dir2/$f1",
		"? $fs/dir1/dir3/$f1",
		"? $fs/dir1/$f1"     ,
		"? $fs/dir1/dir2/$f2",
		"? $fs/dir1/dir3/$f3");

	my @got = sort(
		split(/\n/, &invoke('n', "$fs/dir1")));

	&is_deeply(\@got,\@expected);

    rmtree "$fs/dir1";
}

################################################################################
# Test helpers

sub meta_get() {
    my ($file) = @_;

    my $dump=`getfattr -d '$file'`;

    open my $fh, '<', \$dump;

    my %fields;
    while (<$fh>) {
        next unless m/^[\s]*user.rk.(md5|htime|state|vtime)="(.*)"[\s]*$/;
        $fields{$1} = $2;
    }

	# Individual validation
	not defined $fields{md5}  or  $fields{md5} =~ /^[\da-f]{32}$/  or  die 'Bad hash!';
	not defined $fields{htime}  or  $fields{htime} =~ /\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}/  or  die 'Bad htime!';
	not defined $fields{state}  or  $fields{state} =~ /[VX]/  or  die 'Bad state!';
	not defined $fields{vtime}  or  $fields{vtime} =~ /\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}/  or  die 'Bad htime!';

	# Collective validation: md5 and htime must appear together, and neither state nor vtime must appear without them
	delete @fields{'md5', 'htime', 'state', 'vtime'} if (not (defined $fields{md5} and defined $fields{htime}));
	delete @fields{'state', 'vtime'} if (not defined $fields{state});

    return %fields;
}

sub invoke {
	my ($mode, @files) = (@_);
	run [ $testee, "-$mode", @files ], ">", \my $out or die;
	return $out;
}

sub clobber_file {
	my ($file, $content) = @_;
    system("echo -n '$content' > '$file'");	
}
